                  <meta charset="utf-8">
                      
                       **Report**
                        Lab 2-Rays
               Matheus de Carvalho Souza  +  Youle Chen 
               mc13@williams.edu           
               yc2@williams.edu                  
                      
Rendering Algorithms
=======================================================
- Important Design decisions: 
- Observations:
- "Gotchas":

The reflected radiance at $X$ due to a single, unshadowed point light at $Y$ is given by:

 \begin{equation} \Lo(X, \wo) = \beta(X, Y) \cdot f_X(\wi, \wo) \cdot |\wi \cdot \n| \end{equation}

where $\beta$ is the biradiance function of the light, $f_X$ is the bidirectional scattering
distribution function of the surface at $X$, $\wi$ is the unit vector from $X$ towards $Y$, $\wo$
is the outgoing direction, and $\n$ is the normal to the surface at $X$.

The indirect radiance term is one more iteration of the rendering equation's integral equation
(for nontransmissive surfaces). The total indirect contribution from one indirect scattering
event is therefore:

\begin{equation}
L_\mathrm{reflected~indirect}(X, \wo) = \int_{\mathbf{S}^2_+} \Li^1(X, \wi) \cdot f_X(\wi,\wo) \cdot |\wi \cdot \n| ~ d\wi
\label{eqn:indirect}
\end{equation}

where $\Li^1$ is the "one bounce" (i.e., nonrecursive) incident light function.

Results
=======================================================
(by rendering with ray tracer at 640x400 resolution, and saving to lossless png file)

1. G3D Triangle:

    ![Direct light only](2016-09-26_000_TriangleDLonly.png)

2. G3D Cornell Box:

    ![Direct light only](2016-09-26_DirectLightCornellBox.png)

3. Analytic spheres + triangles:

    ![With indirect light](2016-09-26_spheres+triangles.png)

4. 2048 G3D Cornell Box:

    ![]()

5. G3D Sponza (Report rendering time):

    ![]()

6. Custom Scene:

    ![With indirect lighting](2016-09-26_DemoScene.png)

Running time analysis
=======================================================
Measure and graph the running time of the program with respect to the following, ensuring other parameters are sufficiently large to ensure low variance.
1. Number of cores (1 vs [G3D::System::numCores](http://g3d.cs.williams.edu/g3d/G3D10/build/manual/class_g3_d_1_1_system.html#a4acba57a7c4353b59622dd6225f8e509))

2. Number of triangles (use heightfield to vary the number of triangles)

3. Number of pixels

    ![Pixels x Running Time](Pixels.png)

4. Number of lights

5. Number of indirect rays 


Asymptotic bound
=======================================================
A LONG TIME


Questions
=======================================================
1. How would you derive an analytic intersection algorithm for a finite right cylinder? Do not actually do so.
First we need to know the center of the bottom side C, the height h, and the normal vector from the bottom side n of the cylinder. Then we construct equations of the infinite cylinder and the two infinite planes that makes up the finite cylinder. Afterwards we check whether `P+tw` intersects the infinite cylinder and planes, after that, we check whether the intersections are actually on the finite cylinder. 

2. How would you compute the intersection with a surface for which there was no analytic intersection solution. For example, an arbitrary continuous height function y(x,z). Sketch an algorithm, but do not attempt to refine it.

Let X(a,b,c) be a point, then the equation for the plane would be b=y(a,b). Let P=(d,e,f),w=(g,h,i), then P+tw = (d+tg,e+th,f+ti). Therefore we can construct a function y(d+tg,f+ti)=e+th and calculate the t value.

3. How do you think a binary tree could be leveraged to accelerate the ray intersection process? If you choose to research this (not required) before answering, be sure to cite the resources that you consult.

We can recursively divide the space into two seperate spaces using a plane, ignoring every mesh that is intersected by the plane. Then we can find a mesh that the ray hit, then we recursively obtain all the parent meshes and get the planes that are used to seperate them. If the ray hits the mesh first then hit the plane, we can completely ignore the other side of the plane and discard that side of the binary tree, which would save us a lot of time. 
Source : Fast Ray Tracing Using K-D Trees by Donal Fussel and K.R.Subramanian

Self-evaluation
=======================================================
Youle's self evalutation: B+
coding style: it wasn't the best, some of the codes are messy making the debugging quite difficult, and version control wasn't used to its full potential. However we did use small helper methods to improve the readability of the code.
workflow: We tried pair programming, but the most difficult part is communication, as it takes up effort and time to explain it to the other person. This becomes increasingly difficult during the debugging process, since everyone has their own way of debugging(trying things out), and it is often quite difficult to explain to others. 
report: I am confident that our report will be great. Eventhough we put in most of our effort into the lab itself, we still tried to include most things in the report and in our program, and hopefully it will be in depth. 


Skills Learned
=======================================================
Software: We are now much more familiar with using pointers, the member functions of a class and lambda functions. We are also getting better at reading documentations of G3D engine.
Algorithm: Intersection function, direct and indirect rendering equations. 
Math: review of vector operations including dot product, cross product, vector movements. 

Workflow
=======================================================
 Task                 | Description                                                |Planned Time(h)| Actual Time
 ---------------------|------------------------------------------------------------|--------------:|------------:
 Report Draft         | Formatted Markdeep document with placeholder text.         |     0.50      | 0.50
 GUI MVP    	      |	Copy code from Meshes and add extra specifications link to function |  0.25    | 
 `App::onRender` Draft| skeleteon of procedure, loops, forks, and helper functions linked to the GUI|     0.75      | 
 RayTracer Draft      | Header of class and all it's member functions               |      0.50     |
 Ray intersect Draft  | rough lines of algorithm implementation                     |      0.50     |
 Shading Draft        | Procedure's structure, including inputs and outlining comments|     0.75     | 
 Indirect Rays Draft  | Algorithm's structure and outlining comments                |    0.50       |   
 Ray intersect MVP    | working for all primitives, successfully bumping rays       |      0.50     |
 Shading MVP          | Algorithms working                                          |     0.75      | 
 Indirect Rays MVP    | Algorithms working                                          |    0.50       |    
 RayTracer MVP        | cpp implementation generally working, consistent relationship b/w member functions|      0.75     |
 `App::onRender` MVP  | procedures working preliminarily, maybe with some bugs      |     1.00      | 
 Report MVP           | questions reasoned through and answered                     |     0.50      | 
Ray intersect MVP    | working for all primitives, successfully bumping rays       |      0.50     |
 Ray intersect Polish | Correctly working for all primitives, with satisfactory ray bumping, and as few as possible precision losses|      0.50     |
 Shading Polish       | Correct, and producing satisfactory results                 |     0.50      | 
 Indirect Rays Polish | Correct, and producing satisfactory results                 |    0.50       |    
 RayTracer Polish     | Implementation working with as few bugs as possible, hopefully no bugs|      0.50     |
 `App::onRender` Polish| Procedures working correctly                               |     0.50      | 
 Report Polish        | Questions reviewed and edited appropriately                 |     0.50      |
                                                          
[Table [tbl:workflow]: project planning table.]

Planned works sessions: 
    - 9/22: 1-4pm
    - 9/23: 4-7pm 
    - 9/24: 2-6pm
    - 9/25: 2-6:30pm
    - 9/26: 4-7pm
<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
